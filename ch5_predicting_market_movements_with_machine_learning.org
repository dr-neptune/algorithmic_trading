#+TITLE: Chapter 5: Predicting Market Movements with Machine Learning

This chapter covers the following types of trading strategies:

- linear regression based strategies
- ML based strategies (see above?)
- Deep-learning based strategies

* Using Linear Regression for Market Movement Prediction

** A Quick Overview of Linear Regression

#+begin_src python
import os
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use('tkAgg')

x = np.linspace(0, 10)  # gen evenly spaced grid of floats

# set random seed for rng
def set_seeds(seed=8888):
    random.seed(seed)
    np.random.seed(seed)
    print('ok')

set_seeds()

# generate random data for y values
y = x + np.random.standard_normal(len(x))

# fit an ols regression of degree 1
reg = np.polyfit(x, y, deg=1)
reg

# plot it
plt.figure()
plt.plot(x, y, 'bo', label='data')
plt.plot(x, np.polyval(reg, x), 'r', lw=2.5, label='linear regression')
plt.legend(loc=0)
plt.show()
#+end_src

* The Basic Idea for Price Prediction

Price prediction based on time series data has to deal with the time
index.

#+begin_src python
x = np.arange(12)
x

lags = 3
m = np.zeros((lags + 1, len(x) - lags))

m[lags] = x[lags:]  # target variable y

for i in range(lags):          # iterate over 0 -> lags - 1
    m[i] = x[i:i - lags]       # defines the basis vectors

m.T

reg = np.linalg.lstsq(m[:lags].T, m[lags], rcond=None)[0]  # implement OLS
reg  # print out the optimal parameters

np.dot(m[:lags].T, reg)  # dot product reveals prediction results
#+end_src


* Predicting Index Levels

#+begin_src python
import pandas as pd

# retrieve EOD data
raw = pd.read_csv('https://hilpisch.com/pyalgo_eikon_eod_data.csv',
                  index_col=0, parse_dates=True).dropna()

raw.info()

symbol = 'EUR='

df = pd.DataFrame(raw[symbol]).rename(columns={symbol: 'price'})

lags = 5

cols = []
for lag in range(1, lags + 1):
    col = f'lag_{lag}'
    df[col] = df['price'].shift(lag)
    cols.append(col)
df = df.dropna()

reg = np.linalg.lstsq(df[cols], df['price'], rcond=None)[0]

reg

df['prediction'] = np.dot(df[cols], reg)
df[['price', 'prediction']].loc['2019-10-1':].plot()
plt.show()
#+end_src

We see that today's rate is roughly yesterdays rate, i.e. a shift to
the right by 1 trading day.

* Predicting Future Returns

log returns may be better than absolute rate levels due to, for
example, their characteristic of making the time series data
stationary.

#+begin_src python
df['return'] = np.log(df['price'] / df['price'].shift(1)).dropna()

cols = []
for lag in range(1, lags + 1):
    col = f'lag_{lag}'
    df[col] = df['price'].shift(lag)
    cols.append(col)
df = df.dropna()

reg = np.linalg.lstsq(df[cols], df['return'], rcond=None)[0]

reg

df['prediction'] = np.dot(df[cols], reg)
df[['return', 'prediction']].loc['2019-10-1':].plot()
plt.show()
#+end_src

From a trading pov, one might argue that it is not the magnitude of
the forecasted return that is relevant, but rather whether the
direction is forecasted correctly or not.

#+begin_src python
hits = np.sign(df['return'] * df['prediction']).value_counts()
hits

hits.values[0] / sum(hits)  # 0.5067
#+end_src

not great, pretty much exactly 50/50

* Predicting Future Market Direction

Can we improve the hit ratio by directly implementing the linear
regression based on the sign of the log returns that serve as the
dependendant variables?


#+begin_src python
reg = np.linalg.lstsq(df[cols], np.sign(df['return']), rcond=None)[0]

df['prediction'] = np.sign(np.dot(df[cols], reg))
df['prediction'].value_counts()

hits = np.sign(df['return'] * df['prediction']).value_counts()
hits

hits.values[0] / sum(hits)  # 0.50997
#+end_src

a 0.03% increase

* Vectorized Backtesting of Regression-Based Strategy

The hit ratio alone doesn't tell us too much about the economic
potential of a trading strategy using linear regression in the way
presented so far. It is well known that the 10 worst and best days in
the markets for a given period of time considerably influence the
overall performance of investments. In an ideal world, a long-short
trader would try to benefit from both the best and worst days by going
short and long, respectively, on the basis of appropriate market
timing indicators.

This implies that, in addition to the hit ratio, the quality of market
timing matters.

#+begin_src python
df['strategy'] = df['prediction'] * df['return']

df[['return', 'strategy']].dropna().cumsum().apply(np.exp).dropna().plot()
plt.show()
#+end_src

* Generalizing the Approach

#+begin_src python
class LRVectorBacktester:
    """
    Class for the vectorized backtesting of linear regression-based
    trading strategies.

    Attributes
    ==========
    symbol: str
        TR RIC (financial instrument) to work with
    start: str
        start date for data selection
    end: str
        end date for data selection
    amount: int, float
        amount to be invested at the beginning
    tc: float
        proportional transaction costs (e.g., 0.5% = 0.005) per trade
    Methods
    =======
    get_data:
        retrieves and prepares the base data set
    select_data:
        selects a sub-set of the data
    prepare_lags:
        prepares the lagged data for the regression
    fit_model:
        implements the regression step
    run_strategy:
        runs the backtest for the regression-based strategy
    plot_results:
        plots the performance of the strategy compared to the symbol
    """
    def __init__(self, symbol, start, end, amount, tc):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.amount = amount
        self.tc = tc
        self.results = None
        self.get_data()

    def get_data(self):
        raw = pd.read_csv('https://hilpisch.com/pyalgo_eikon_eod_data.csv',
                          index_col=0, parse_dates=True).dropna()
        raw = pd.DataFrame(raw[self.symbol])
        raw = raw.loc[self.start:self.end].rename(columns={self.symbol: 'price'})
        raw['returns'] = np.log(raw / raw.shift(1))
        self.data = raw.dropna()

    def select_data(self, start, end):
        """selects subsets of the financial data"""
        data = self.data[(self.data.index >= start) &
                         (self.data.index <= end)]
        return data

    def prepare_lags(self, start, end):
        """Prepares the lagged data for the regression and prediction steps"""
        data = self.select_data(start, end)
        self.cols = []
        for lag in range(1, self.lags + 1):
            col = f'lag_{lag}'
            data[col] = data['returns'].shift(lag)
            self.cols.append(col)
        data = data.dropna()
        self.lagged_data = data

    def fit_model(self, start, end):
        self.prepare_lags(start, end)
        reg = np.linalg.lstsq(self.lagged_data[self.cols],
                              np.sign(self.lagged_data['returns']),
                              rcond=None)[0]
        self.reg = reg

    def run_strategy(self, start_in, end_in, start_out, end_out, lags=3):
        """backtests the trading strategy"""
        self.lags = lags
        self.fit_model(start_in, end_in)
        self.results = self.select_data(start_out, end_out).iloc[lags:]
        self.prepare_lags(start_out, end_out)
        prediction = np.sign(np.dot(self.lagged_data[self.cols], self.reg))
        self.results['prediction'] = prediction
        self.results['strategy'] = self.results['prediction'] * self.results['returns']

        # determine when a trade takes place
        trades = self.results['prediction'].diff().fillna(0) != 0

        # subtract transaction costs from return when trade takes place
        self.results['strategy'][trades] -= self.tc
        self.results['creturns'] = (self.amount *
                                    self.results['returns']
                                    .cumsum()
                                    .apply(np.exp))
        self.results['cstrategy'] = (self.amount *
                                     self.results['strategy']
                                     .cumsum()
                                     .apply(np.exp))

        # gross performance of the strategy
        aperf = self.results['cstrategy'].iloc[-1]
        operf = aperf - self.results['creturns'].iloc[-1]
        return round(aperf, 2), round(operf, 2)

    def plot_results(self):
        """plots the cumulative performance of the trading strategy compared to the symbol"""
        if self.results is None:
            print('No results to plot yet. Run a strategy')
        title = '%s | TC = %.4f' % (self.symbol, self.tc)
        self.results[['creturns', 'cstrategy']].plot(title=title)
        plt.show()
#+end_src

#+begin_src python
lrbt = LRVectorBacktester('EUR=', '2010-1-1', '2019-12-31', 10000, 0.0)
lrbt.run_strategy('2010-1-1', '2019-12-31', '2010-1-1', '2019-12-31', lags=5)
lrbt.plot_results()
lrbt.run_strategy('2010-1-1', '2017-12-31', '2018-1-1', '2019-12-31', lags=5)
lrbt.plot_results()
#+end_src

* Using Machine Learning for Market Movement Prediction

** Linear Regression with scikit-learn

#+begin_src python
from sklearn import linear_model

x = np.arange(12)
lags = 3
m = np.zeros((lags + 1, len(x) - lags))

# make a lattice
m[lags] = x[lags:]
for i in range(lags):
    m[i] = x[i:i - lags]

lm = linear_model.LinearRegression()
lm.fit(m[:lags].T, m[lags])

lm.coef_
lm.intercept_

lm.predict(m[:lags].T)
#+end_src

** A Simple Classification Problem
